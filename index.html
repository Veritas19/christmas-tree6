<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#07060a" />
  <title>Warm Xmas Tree â€” Gesture Stable</title>
  <style>
    :root{
      --padL: calc(12px + env(safe-area-inset-left));
      --padR: calc(12px + env(safe-area-inset-right));
      --padT: calc(12px + env(safe-area-inset-top));
      --padB: calc(12px + env(safe-area-inset-bottom));
    }
    html,body{margin:0;height:100%;background:#07060a;overflow:hidden;
      font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"PingFang SC","Microsoft YaHei",Arial;}
    #three{position:fixed;inset:0;width:100%;height:100%;display:block;touch-action:none;}
    #vignette{position:fixed;inset:0;pointer-events:none;z-index:5;
      background:radial-gradient(ellipse at center, rgba(0,0,0,0) 40%, rgba(0,0,0,.28) 100%);opacity:.92;}
    #ui{
      position:fixed;left:var(--padL);top:var(--padT);z-index:10;
      display:flex;gap:10px;flex-wrap:wrap;align-items:center;
      padding:10px 12px;border-radius:16px;
      background:rgba(18,14,22,.52);border:1px solid rgba(255,255,255,.10);
      backdrop-filter:blur(10px);color:#ffe9d6;box-shadow:0 18px 60px rgba(0,0,0,.30);
      max-width:calc(100% - var(--padL) - var(--padR));
    }
    #ui .group{display:flex;gap:8px;align-items:center;padding-right:10px;border-right:1px solid rgba(255,255,255,.10);}
    #ui .group:last-child{border-right:none;padding-right:0;}
    button,select,input[type="file"]::file-selector-button{
      background:rgba(255,255,255,.10);color:#ffe9d6;border:1px solid rgba(255,255,255,.14);
      padding:8px 10px;border-radius:12px;cursor:pointer;font-size:13px;
    }
    button:hover,select:hover,input[type="file"]::file-selector-button:hover{background:rgba(255,255,255,.14);}
    input[type="file"]{color:#ffe9d6;font-size:13px;max-width:220px;}
    input[type="range"]{width:120px;}
    .pill{
      padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.08);font-size:12px;color:#ffe9d6;white-space:nowrap;
      max-width:100%;
    }
    #hint{
      position:fixed;left:var(--padL);bottom:var(--padB);z-index:10;
      max-width:calc(100% - var(--padL) - var(--padR));
      padding:10px 12px;border-radius:16px;
      background:rgba(18,14,22,.50);border:1px solid rgba(255,255,255,.10);
      backdrop-filter:blur(10px);color:#ffe9d6;font-size:13px;line-height:1.35;
      box-shadow:0 18px 60px rgba(0,0,0,.30);
    }
    #hint b{color:#fff;}
    #loading{
      position:fixed;inset:0;z-index:25;display:flex;align-items:center;justify-content:center;
      background:radial-gradient(ellipse at center, rgba(255,210,150,.12), rgba(7,6,10,.92));
      color:#ffe9d6;font-size:14px;
    }
    #loading .card{
      padding:14px 16px;border-radius:16px;
      background:rgba(18,14,22,.72);border:1px solid rgba(255,255,255,.10);
      backdrop-filter:blur(10px);box-shadow:0 22px 90px rgba(0,0,0,.40);
      max-width:min(520px, calc(100% - 24px));line-height:1.45;
    }
    #errorBox{
      position:fixed;right:var(--padR);top:var(--padT);z-index:30;display:none;
      width:min(560px, calc(100% - var(--padL) - var(--padR)));
      padding:10px 12px;border-radius:16px;white-space:pre-wrap;
      background:rgba(120,20,20,.35);border:1px solid rgba(255,255,255,.12);
      backdrop-filter:blur(8px);color:#ffecec;font-size:12px;line-height:1.35;
    }

    /* è§†é¢‘ä¸è¦ display:noneï¼ˆiOS/Safari å¯èƒ½ä¸å–‚å¸§ï¼‰ */
    #video{
      position:fixed;right:var(--padR);bottom:var(--padB);z-index:10;
      width:160px;height:120px;border-radius:12px;opacity:0;pointer-events:none;
      transform:scaleX(-1);
    }

    #audioGate,#camGate{
      position:fixed;inset:0;z-index:21;display:none;align-items:center;justify-content:center;
      background:radial-gradient(ellipse at center, rgba(36,22,22,.55), rgba(7,6,10,.90));
      color:#fff2e7;
    }
    #audioGate{z-index:20;}
    #audioGate .card,#camGate .card{
      width:min(580px, calc(100% - 24px));
      border-radius:20px;padding:16px 16px 14px;
      background:rgba(18,14,22,.86);border:1px solid rgba(255,255,255,.12);
      backdrop-filter:blur(10px);box-shadow:0 22px 90px rgba(0,0,0,.45);
    }
    #audioGate .row,#camGate .row{display:flex;gap:10px;margin-top:12px;flex-wrap:wrap;}
    @media (max-width:720px){
      #hint{font-size:12px;line-height:1.28;opacity:.92;}
      input[type="file"]{max-width:160px;}
      input[type="range"]{width:96px;}
    }
  </style>
</head>

<body>
  <canvas id="three"></canvas>
  <div id="vignette"></div>
  <div id="errorBox"></div>

  <div id="loading">
    <div class="card">
      <div style="font-weight:700;font-size:15px;">æ­£åœ¨åŠ è½½åœ£è¯æ ‘â€¦</div>
      <div style="opacity:.88;margin-top:6px;">è‹¥ 3 ç§’åä»æ— ç”»é¢ï¼Œè¯·çœ‹å³ä¸Šè§’é”™è¯¯æç¤ºï¼ˆä¼šè‡ªåŠ¨æ˜¾ç¤ºï¼‰ã€‚</div>
    </div>
  </div>

  <video id="video" playsinline muted></video>

  <div id="ui">
    <div class="group">
      <button id="musicBtn">éŸ³ä¹ï¼šæ’­æ”¾</button>
      <button id="muteBtn">ğŸ”Š</button>
      <input id="vol" type="range" min="0" max="1" step="0.01" value="0.30" />
      <span class="pill" id="musicPill">BGM: auto</span>
    </div>

    <div class="group">
      <input id="photoInput" type="file" accept="image/*" multiple />
      <span class="pill" id="photoCount">0/7</span>
      <button id="resetPhotosBtn">æ¸…ç©ºç…§ç‰‡</button>
    </div>

    <div class="group">
      <button id="camBtn">æ‘„åƒå¤´ï¼šå…³é—­</button>
      <select id="camSelect" style="max-width:180px;">
        <option value="">é»˜è®¤æ‘„åƒå¤´</option>
      </select>
      <span class="pill" id="camPill">Gesture: off</span>
      <span class="pill" id="gesturePill">è¯†åˆ«ï¼š-</span>
      <span class="pill" id="gestureDbg">dbg:-</span>
    </div>

    <div class="group">
      <span class="pill" id="modePill">çŠ¶æ€ï¼šåˆæ‹¢æ€</span>
    </div>
  </div>

  <div id="hint">
    <div><b>æ‰‹åŠ¿</b>ï¼šæ¡æ‹³=å›åˆæ‹¢ï¼›äº”æŒ‡å¼ å¼€=æ•£å¼€ï¼›<b>æ•£å¼€æ€ä¿æŒäº”æŒ‡å¼ å¼€</b>â†’ç§»åŠ¨/æ‰‹è…•æ—‹è½¬=æ—‹è½¬è§†è§’ï¼›æ‹‡æŒ‡+é£ŸæŒ‡ pinch=æŠ“å–ç…§ç‰‡æ”¾å¤§ï¼›æ¾å¼€=å›åŸä½ã€‚</div>
    <div style="opacity:.85;margin-top:6px;">æç¤ºï¼šGitHub Pages å¿…é¡» HTTPS æ‰èƒ½å¼€æ‘„åƒå¤´ï¼›è‹¥æ›´æ–°åä»æ—§æ˜¯æ—§ç‰ˆæ•ˆæœï¼Œè¯•è¯•åœ¨é“¾æ¥ååŠ  <b>?v=2</b> å¼ºåˆ¶åˆ·æ–°ç¼“å­˜ã€‚</div>
  </div>

  <div id="audioGate">
    <div class="card">
      <div style="font-size:16px;font-weight:700;">ç‚¹å‡»å¼€å¯éŸ³ä¹</div>
      <div style="margin-top:8px;opacity:.92;line-height:1.4;">
        æµè§ˆå™¨é€šå¸¸ç¦æ­¢ç½‘é¡µæœªäº¤äº’å‰è‡ªåŠ¨æ’­æ”¾å£°éŸ³ã€‚ç‚¹ä¸€æ¬¡å³å¯å¼€å¯æ›´ä¸æ»‘çš„åœ£è¯ BGMã€‚
      </div>
      <div class="row">
        <button id="audioGateBtn">å¼€å¯éŸ³ä¹</button>
        <button id="audioGateMute">ä¸æ’­æ”¾</button>
      </div>
    </div>
  </div>

  <div id="camGate">
    <div class="card">
      <div style="font-size:16px;font-weight:700;">å¼€å¯æ‘„åƒå¤´ä»¥å¯ç”¨æ‰‹åŠ¿äº¤äº’</div>
      <div style="margin-top:8px;opacity:.92;line-height:1.4;">
        éœ€è¦æ‘„åƒå¤´æƒé™æ‰èƒ½è¯†åˆ«ï¼šæ¡æ‹³ / äº”æŒ‡å¼ å¼€ / pinchã€‚ç‚¹å‡»ä¸‹é¢æŒ‰é’®å¹¶å…è®¸æƒé™ã€‚
      </div>
      <div class="row">
        <button id="camGateBtn">å¼€å¯æ‘„åƒå¤´</button>
        <button id="camGateClose">å…ˆä¸å¯ç”¨</button>
      </div>
    </div>
  </div>

  <!-- THREE -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/shaders/BokehShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/MaskPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/BokehPass.js"></script>

  <!-- MediaPipe Hands (pinned) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"></script>

  <script>
    /********************
     * Error overlay
     ********************/
    const $ = (id)=>document.getElementById(id);
    const errorBox = $("errorBox");
    const loading = $("loading");
    function showError(msg){ errorBox.style.display="block"; errorBox.textContent=msg; loading.style.display="none"; }
    window.addEventListener("error",(e)=>showError("JS Error:\n"+(e.message||e.error)+"\n"+(e.filename||"")+":"+(e.lineno||"")));
    window.addEventListener("unhandledrejection",(e)=>showError("Promise Rejection:\n"+(e.reason?.message||e.reason)));

    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp=(a,b,t)=>a+(b-a)*t;
    const now=()=>performance.now()/1000;

    const isMobileLike = (() => {
      const ua=navigator.userAgent||"";
      return /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(ua) || Math.min(screen.width, screen.height) <= 820;
    })();

    /********************
     * Audio: smooth procedural Xmas (Jingle Bells-like)
     ********************/
    class AudioManager{
      constructor(){ this.ctx=null; this.master=null; this.musicBus=null; this.ambBus=null;
        this.isOn=false; this.muted=false; this.vol=0.30;
        this.tempo=112; this.lookAhead=0.12; this.scheduleAhead=0.70; this.nextTime=0; this.idx=0;
        this.seq=this.makeSeq(); this.chords=this.makeChords(); }
      async init(){
        if(this.ctx) return;
        const Ctx=window.AudioContext||window.webkitAudioContext;
        this.ctx=new Ctx();
        const comp=this.ctx.createDynamicsCompressor();
        comp.threshold.value=-22; comp.knee.value=24; comp.ratio.value=3.2; comp.attack.value=0.012; comp.release.value=0.22;
        this.master=this.ctx.createGain(); this.master.gain.value=this.vol;
        comp.connect(this.master); this.master.connect(this.ctx.destination);

        this.musicBus=this.ctx.createGain(); this.musicBus.gain.value=0.82;
        const lp=this.ctx.createBiquadFilter(); lp.type="lowpass"; lp.frequency.value=2200; lp.Q.value=0.7;
        const delay=this.ctx.createDelay(0.35); delay.delayTime.value=0.12;
        const fb=this.ctx.createGain(); fb.gain.value=0.18;
        const delayLP=this.ctx.createBiquadFilter(); delayLP.type="lowpass"; delayLP.frequency.value=1600;

        this.musicBus.connect(lp); lp.connect(comp);
        this.musicBus.connect(delay); delay.connect(delayLP); delayLP.connect(comp);
        delayLP.connect(fb); fb.connect(delay);

        this.ambBus=this.ctx.createGain(); this.ambBus.gain.value=0.34; this.ambBus.connect(comp);
        this.startAmbience();
      }
      setVolume(v){ this.vol=v; if(this.master) this.master.gain.value=this.muted?0:v; }
      toggleMute(){ this.muted=!this.muted; if(this.master) this.master.gain.value=this.muted?0:this.vol; }
      async tryStart(){ await this.init(); try{ await this.ctx.resume(); }catch{} if(this.ctx.state!=="running") return false; this.start(); return true; }
      start(){ if(!this.ctx) return; this.isOn=true; this.idx=0; this.nextTime=this.ctx.currentTime+0.05; this.scheduler(); }
      stop(){ this.isOn=false; }
      startAmbience(){
        const bufferSize=this.ctx.sampleRate*2;
        const noiseBuffer=this.ctx.createBuffer(1,bufferSize,this.ctx.sampleRate);
        const data=noiseBuffer.getChannelData(0);
        for(let i=0;i<bufferSize;i++) data[i]=(Math.random()*2-1)*0.08;
        const noise=this.ctx.createBufferSource(); noise.buffer=noiseBuffer; noise.loop=true;
        const lp=this.ctx.createBiquadFilter(); lp.type="lowpass"; lp.frequency.value=520;
        const hp=this.ctx.createBiquadFilter(); hp.type="highpass"; hp.frequency.value=90;
        const g=this.ctx.createGain(); g.gain.value=0.20;
        noise.connect(lp); lp.connect(hp); hp.connect(g); g.connect(this.ambBus); noise.start();
        const osc=this.ctx.createOscillator(); osc.type="sine"; osc.frequency.value=55;
        const og=this.ctx.createGain(); og.gain.value=0.018; osc.connect(og); og.connect(this.ambBus); osc.start();
      }
      mtof(m){ return 440*Math.pow(2,(m-69)/12); }
      playBell(freq,time,dur,vel=0.16){
        const o1=this.ctx.createOscillator(), o2=this.ctx.createOscillator();
        const g=this.ctx.createGain(), lp=this.ctx.createBiquadFilter();
        o1.type="sine"; o2.type="triangle";
        o1.frequency.setValueAtTime(freq,time);
        o2.frequency.setValueAtTime(freq*2.004,time);
        lp.type="lowpass"; lp.frequency.setValueAtTime(2600,time);
        g.gain.setValueAtTime(0.0001,time);
        g.gain.exponentialRampToValueAtTime(vel,time+0.016);
        g.gain.exponentialRampToValueAtTime(0.0001,time+dur);
        o1.connect(lp); o2.connect(lp); lp.connect(g); g.connect(this.musicBus);
        o1.start(time); o2.start(time); o1.stop(time+dur+0.02); o2.stop(time+dur+0.02);
      }
      playPadChord(notes,time,dur,vel=0.045){
        const g=this.ctx.createGain();
        g.gain.setValueAtTime(0.0001,time);
        g.gain.exponentialRampToValueAtTime(vel,time+0.08);
        g.gain.exponentialRampToValueAtTime(0.0001,time+dur);
        const lp=this.ctx.createBiquadFilter(); lp.type="lowpass"; lp.frequency.setValueAtTime(780,time);
        g.connect(lp); lp.connect(this.musicBus);
        notes.forEach((m,idx)=>{
          const o=this.ctx.createOscillator(); o.type="sawtooth";
          o.frequency.setValueAtTime(this.mtof(m)*(idx===0?0.5:1),time);
          o.detune.setValueAtTime((idx-1)*8,time);
          o.connect(g); o.start(time); o.stop(time+dur+0.02);
        });
      }
      scheduler=()=>{
        if(!this.isOn||!this.ctx) return;
        const ct=this.ctx.currentTime, beat=60/this.tempo;
        while(this.nextTime<ct+this.scheduleAhead){
          const step=this.seq[this.idx%this.seq.length];
          if(step.m!==null) this.playBell(this.mtof(step.m),this.nextTime,step.d*beat,0.14+step.v*0.05);
          const chord=this.chords.find(c=>c.at===(this.idx%this.seq.length));
          if(chord) this.playPadChord(chord.m,this.nextTime,chord.d*beat,0.040);
          this.nextTime+=step.d*beat; this.idx++;
        }
        setTimeout(this.scheduler,this.lookAhead*1000);
      }
      makeSeq(){
        const E5=76,D5=74,C5=72,G4=67,F5=77;
        return [
          {m:E5,d:1,v:.7},{m:E5,d:1,v:.4},{m:E5,d:2,v:.8},
          {m:E5,d:1,v:.6},{m:E5,d:1,v:.4},{m:E5,d:2,v:.8},
          {m:E5,d:1,v:.7},{m:G4,d:1,v:.3},{m:C5,d:1,v:.5},{m:D5,d:1,v:.5},{m:E5,d:4,v:.8},
          {m:F5,d:1,v:.7},{m:F5,d:1,v:.4},{m:F5,d:1.5,v:.6},{m:F5,d:0.5,v:.3},
          {m:F5,d:1,v:.4},{m:E5,d:1,v:.4},{m:E5,d:1,v:.4},{m:E5,d:0.5,v:.3},{m:E5,d:0.5,v:.3},
          {m:D5,d:1,v:.4},{m:D5,d:1,v:.4},{m:E5,d:1,v:.4},{m:D5,d:2,v:.5},{m:G4,d:2,v:.3},
        ];
      }
      makeChords(){
        const C=[60,64,67], G=[55,59,62], F=[53,57,60], Am=[57,60,64];
        return [
          {at:0,m:C,d:4},{at:3,m:C,d:4},{at:6,m:Am,d:4},{at:10,m:G,d:4},
          {at:12,m:F,d:4},{at:16,m:C,d:4},{at:20,m:G,d:4},{at:24,m:C,d:4},
        ];
      }
    }

    const audio=new AudioManager();
    const audioGate=$("audioGate");
    const audioGateBtn=$("audioGateBtn");
    const audioGateMute=$("audioGateMute");
    const musicBtn=$("musicBtn");
    const muteBtn=$("muteBtn");
    const vol=$("vol");
    const musicPill=$("musicPill");
    let musicPlaying=false;

    async function startMusicWithGate(){
      const ok=await audio.tryStart();
      if(!ok){ audioGate.style.display="flex"; return false; }
      audioGate.style.display="none";
      musicPlaying=true;
      musicBtn.textContent="éŸ³ä¹ï¼šæš‚åœ";
      musicPill.textContent="BGM: on";
      return true;
    }
    audioGateBtn.addEventListener("click", async ()=>{ await startMusicWithGate(); });
    audioGateMute.addEventListener("click", ()=>{ audioGate.style.display="none"; musicPill.textContent="BGM: off"; });
    musicBtn.addEventListener("click", async ()=>{
      if(!musicPlaying) await startMusicWithGate();
      else{ audio.stop(); musicPlaying=false; musicBtn.textContent="éŸ³ä¹ï¼šæ’­æ”¾"; musicPill.textContent="BGM: off"; }
    });
    muteBtn.addEventListener("click", ()=>{ audio.toggleMute(); muteBtn.textContent=audio.muted?"ğŸ”‡":"ğŸ”Š"; });
    vol.addEventListener("input",(e)=>audio.setVolume(parseFloat(e.target.value)));
    startMusicWithGate();
    window.addEventListener("pointerdown", async ()=>{ if(!musicPlaying && audioGate.style.display!=="flex") await startMusicWithGate(); }, {once:false});

    /********************
     * Three.js scene
     ********************/
    const COLORS={
      goldBright:new THREE.Color("#ffd86b"),
      redBright:new THREE.Color("#ff1c2b"),
      orangeStar:new THREE.Color("#ffb24a"),
      warmFog:new THREE.Color("#0d0710")
    };

    const canvas=$("three");
    const renderer=new THREE.WebGLRenderer({canvas,antialias:true,alpha:true,powerPreference:"high-performance"});
    renderer.setSize(innerWidth,innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, isMobileLike?1.6:2));
    renderer.outputColorSpace=THREE.SRGBColorSpace;
    renderer.toneMapping=THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure=1.72; // æ›´æš–æ›´äº®

    const scene=new THREE.Scene();
    scene.background=new THREE.Color(0x07060a);
    scene.fog=new THREE.FogExp2(COLORS.warmFog, 0.048);

    const camera=new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 120);

    // warm cinematic lighting
    scene.add(new THREE.AmbientLight(0xffe6cf, 0.44));
    scene.add(new THREE.HemisphereLight(0xffddb3, 0x141028, 1.28));
    const key=new THREE.PointLight(0xffd1a6, 3.2, 34); key.position.set(3.2,6.2,6.0); scene.add(key);
    const fill=new THREE.PointLight(0xffcaa0, 1.05, 26); fill.position.set(-5.2,2.8,3.4); scene.add(fill);
    const rim=new THREE.PointLight(0xfff0d0, 1.65, 30); rim.position.set(0.0,6.4,-6.0); scene.add(rim);

    // post: bloom + bokeh
    let composer=null, bloomPass=null, bokehPass=null;
    try{
      composer=new THREE.EffectComposer(renderer);
      composer.addPass(new THREE.RenderPass(scene,camera));
      bloomPass=new THREE.UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight), 1.65, 0.78, 0.14);
      composer.addPass(bloomPass);
      bokehPass=new THREE.BokehPass(scene,camera,{focus:7.0, aperture:isMobileLike?0.00022:0.00026, maxblur:isMobileLike?0.015:0.020});
      composer.addPass(bokehPass);
    }catch{ composer=null; bloomPass=null; bokehPass=null; }

    const treeGroup=new THREE.Group(); scene.add(treeGroup);
    const overlayGroup=new THREE.Group(); scene.add(overlayGroup);

    let treeScale=1.0;
    function applyLayoutByAspect(){
      const aspect=innerWidth/Math.max(1,innerHeight);
      if(aspect<0.85){ camera.fov=62; camera.position.set(0,2.12,8.2); treeScale=0.95; }
      else if(aspect<1.15){ camera.fov=58; camera.position.set(0,2.22,7.5); treeScale=1.0; }
      else { camera.fov=55; camera.position.set(0,2.32,7.1); treeScale=1.02; }
      camera.aspect=aspect; camera.updateProjectionMatrix();
      treeGroup.scale.setScalar(treeScale);
    }
    applyLayoutByAspect();

    // ground
    const ground=new THREE.Mesh(
      new THREE.CircleGeometry(6.2, 80),
      new THREE.MeshBasicMaterial({color:0x15112a,transparent:true,opacity:0.42})
    );
    ground.rotation.x=-Math.PI/2; ground.position.y=-0.06; treeGroup.add(ground);

    // trunk
    const trunk=new THREE.Mesh(
      new THREE.CylinderGeometry(0.26,0.40,1.45,22),
      new THREE.MeshStandardMaterial({color:0x3a2a20,roughness:0.95,metalness:0.0})
    );
    trunk.position.y=0.62; treeGroup.add(trunk);

    // star (bigger angles via 5-point shape)
    function makeStarMesh(){
      const outer=0.68, inner=0.10;
      const shape=new THREE.Shape();
      for(let i=0;i<10;i++){
        const a=(i/10)*Math.PI*2 - Math.PI/2;
        const r=(i%2===0)?outer:inner;
        const x=Math.cos(a)*r, y=Math.sin(a)*r;
        if(i===0) shape.moveTo(x,y); else shape.lineTo(x,y);
      }
      shape.closePath();
      const geo=new THREE.ExtrudeGeometry(shape,{depth:0.11, bevelEnabled:true, bevelThickness:0.035, bevelSize:0.035, bevelSegments:3});
      geo.center();
      const mat=new THREE.MeshStandardMaterial({
        color:COLORS.orangeStar, metalness:1.0, roughness:0.14,
        emissive:new THREE.Color(0x442000), emissiveIntensity:1.05
      });
      return new THREE.Mesh(geo,mat);
    }
    function makeGlowTexture(){
      const c=document.createElement("canvas"); c.width=256; c.height=256;
      const ctx=c.getContext("2d");
      const g=ctx.createRadialGradient(128,128,12,128,128,128);
      g.addColorStop(0.0,"rgba(255,220,150,0.95)");
      g.addColorStop(0.35,"rgba(255,200,120,0.32)");
      g.addColorStop(1.0,"rgba(255,190,110,0.0)");
      ctx.fillStyle=g; ctx.fillRect(0,0,256,256);
      const tex=new THREE.CanvasTexture(c); tex.colorSpace=THREE.SRGBColorSpace; return tex;
    }
    const star=makeStarMesh();
    star.position.set(0,5.34,0);
    treeGroup.add(star);
    const starGlow=new THREE.Sprite(new THREE.SpriteMaterial({
      map:makeGlowTexture(), transparent:true, opacity:0.44, blending:THREE.AdditiveBlending, depthWrite:false
    }));
    starGlow.position.copy(star.position);
    starGlow.scale.set(2.9,2.9,1);
    treeGroup.add(starGlow);

    // needles points
    let needlePoints=null, needleCount=isMobileLike?10000:16000;
    function buildNeedles(count){
      const geo=new THREE.BufferGeometry();
      const pos=new Float32Array(count*3);
      const col=new Float32Array(count*3);
      const height=4.95, baseR=2.60;

      const levels=14, branches=[];
      for(let i=0;i<levels;i++){
        const t=i/(levels-1);
        const y=0.35+t*height;
        const ringR=(1-t)*baseR;
        const bCount=Math.round(lerp(16,6,t));
        for(let j=0;j<bCount;j++){
          const ang=(j/bCount)*Math.PI*2+i*0.18;
          const len=ringR*(0.70+Math.random()*0.42);
          const pitch=lerp(0.18,0.38,t);
          branches.push({x1:0,y1:y,z1:0,x2:Math.cos(ang)*len,y2:y+len*pitch,z2:Math.sin(ang)*len,t});
        }
      }

      for(let i=0;i<count;i++){
        let x,y,z,t;
        if(Math.random()<0.74){
          const b=branches[(Math.random()*branches.length)|0];
          const u=Math.pow(Math.random(),0.62);
          const bx=lerp(b.x1,b.x2,u), by=lerp(b.y1,b.y2,u), bz=lerp(b.z1,b.z2,u);
          const needle=lerp(0.10,0.22,1-b.t)*(0.85+Math.random()*0.6);
          const a=Math.random()*Math.PI*2;
          const r=needle*Math.pow(Math.random(),0.55);
          x=bx+Math.cos(a)*r;
          y=by+(Math.random()*2-1)*needle*0.55;
          z=bz+Math.sin(a)*r;
          t=clamp((y-0.35)/height,0,1);
        }else{
          const u=Math.random();
          y=Math.pow(u,0.70)*height+0.35;
          t=(y-0.35)/height;
          const rr=(1-t)*baseR*(0.55+Math.random()*0.55);
          const ang=Math.random()*Math.PI*2;
          const hollow=0.25+Math.random()*0.75;
          x=Math.cos(ang)*rr*hollow; z=Math.sin(ang)*rr*hollow;
        }
        pos[i*3]=x; pos[i*3+1]=y; pos[i*3+2]=z;

        const g=lerp(0.26,0.70,1-t);
        const rC=lerp(0.08,0.16,t);
        const bC=lerp(0.10,0.22,t);
        col[i*3]=rC+Math.random()*0.02;
        col[i*3+1]=g+Math.random()*0.06;
        col[i*3+2]=bC+Math.random()*0.02;
      }

      geo.setAttribute("position",new THREE.BufferAttribute(pos,3));
      geo.setAttribute("color",new THREE.BufferAttribute(col,3));
      const mat=new THREE.PointsMaterial({size:0.046,vertexColors:true,transparent:true,opacity:0.98,depthWrite:false,blending:THREE.AdditiveBlending});
      return new THREE.Points(geo,mat);
    }
    function rebuildNeedles(){
      if(needlePoints) treeGroup.remove(needlePoints);
      needlePoints=buildNeedles(needleCount);
      treeGroup.add(needlePoints);
    }
    rebuildNeedles();

    // ornaments (only bright gold & bright red)
    const tmpObj=new THREE.Object3D();
    function randInSphere(r){
      const u=Math.random(), v=Math.random();
      const theta=u*Math.PI*2;
      const phi=Math.acos(2*v-1);
      const rr=r*Math.pow(Math.random(),0.72);
      return new THREE.Vector3(rr*Math.sin(phi)*Math.cos(theta), rr*Math.cos(phi), rr*Math.sin(phi)*Math.sin(theta));
    }
    function coneSurfacePos(t, ang, baseR=2.35, height=4.7){
      const y=0.55+t*height;
      const r=(1-t)*baseR;
      return new THREE.Vector3(Math.cos(ang)*r, y, Math.sin(ang)*r);
    }
    function buildInstancedBalls(count, material){
      const geo=new THREE.SphereGeometry(0.108, 20, 20);
      const mesh=new THREE.InstancedMesh(geo, material, count);
      mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      treeGroup.add(mesh);
      const folded=[], scatter=[], seed=[];
      for(let i=0;i<count;i++){
        const t=clamp(Math.pow(Math.random(),0.78),0.05,0.98);
        const ang=Math.random()*Math.PI*2;
        folded.push(coneSurfacePos(t,ang).multiplyScalar(1.02));
        scatter.push(randInSphere(3.6).add(new THREE.Vector3(0,2.0,0)));
        seed.push(Math.random()*Math.PI*2);
      }
      return {mesh,count,folded,scatter,seed};
    }
    function updateInstanced(data, mix, t){
      const mesh=data.mesh;
      for(let i=0;i<data.count;i++){
        const f=data.folded[i], s=data.scatter[i], seed=data.seed[i];
        const p=new THREE.Vector3(lerp(f.x,s.x,mix), lerp(f.y,s.y,mix), lerp(f.z,s.z,mix));
        const drift=mix;
        p.x += Math.sin(t*0.9+seed)*0.10*drift;
        p.y += Math.sin(t*0.7+seed*1.3)*0.06*drift;
        p.z += Math.cos(t*0.8+seed*0.8)*0.10*drift;

        tmpObj.position.copy(p);
        tmpObj.rotation.set((seed*2+t*0.4)*drift*0.7, (seed+t*0.35)*drift, (seed*1.7+t*0.3)*drift*0.5);
        tmpObj.updateMatrix();
        mesh.setMatrixAt(i,tmpObj.matrix);
      }
      mesh.instanceMatrix.needsUpdate=true;
    }

    const goldBallMat=new THREE.MeshStandardMaterial({
      color:COLORS.goldBright, metalness:1.0, roughness:0.10,
      emissive:new THREE.Color(0x3a1a00), emissiveIntensity:0.48
    });
    const redBallMat=new THREE.MeshStandardMaterial({
      color:COLORS.redBright, metalness:0.42, roughness:0.20,
      emissive:new THREE.Color(0x3a0000), emissiveIntensity:0.34
    });
    const ballsGold=buildInstancedBalls(78, goldBallMat);
    const ballsRed =buildInstancedBalls(78, redBallMat);

    // Helix: standard in fold, flowing in scatter
    const helixGroup=new THREE.Group(); treeGroup.add(helixGroup);
    function buildHelix(){
      const pts=[];
      const y0=0.70, y1=5.05;
      const turns=5.6, samples=170;
      const baseR=2.25;
      for(let i=0;i<=samples;i++){
        const s=i/samples;
        const y=lerp(y0,y1,s);
        const r=(1-s)*baseR*0.92 + 0.18;
        const a=s*turns*Math.PI*2;
        pts.push(new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r));
      }
      const curve=new THREE.CatmullRomCurve3(pts,false,"catmullrom",0.0);
      const geoCore=new THREE.TubeGeometry(curve, 520, 0.022, 12, false);
      const geoHalo=new THREE.TubeGeometry(curve, 520, 0.064, 12, false);
      return {geoCore,geoHalo,y0,y1};
    }
    const helixGeom=buildHelix();
    function makeFlowTubeMaterial(colorHex, baseOpacity, additive=false){
      return new THREE.ShaderMaterial({
        transparent:true, depthWrite:false,
        blending:additive?THREE.AdditiveBlending:THREE.NormalBlending,
        uniforms:{
          uTime:{value:0}, uMix:{value:0},
          uColor:{value:new THREE.Color(colorHex)},
          uOpacity:{value:baseOpacity}, uY0:{value:helixGeom.y0}, uY1:{value:helixGeom.y1}
        },
        vertexShader:`
          uniform float uTime; uniform float uMix; uniform float uY0; uniform float uY1;
          varying float vFade;
          void main(){
            vec3 p=position;
            float h=clamp((p.y-uY0)/max(0.0001,(uY1-uY0)),0.0,1.0);
            float a=uMix;
            float w1=sin(p.y*4.2+uTime*2.2);
            float w2=sin(p.y*7.1-uTime*1.6);
            float w3=cos(p.y*5.3+uTime*1.9);
            float amp=a*(0.09+0.05*sin(uTime*0.9+h*6.28));
            p.x += amp*(w1+0.6*w2);
            p.z += amp*(w3+0.6*w2);
            p.y += a*0.035*sin(uTime*1.4+h*10.0);
            vFade=smoothstep(0.02,0.18,h)*(1.0-smoothstep(0.82,0.98,h));
            gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.0);
          }
        `,
        fragmentShader:`
          uniform vec3 uColor; uniform float uOpacity;
          varying float vFade;
          void main(){ gl_FragColor=vec4(uColor, uOpacity*vFade); }
        `
      });
    }
    const helixCoreMat=makeFlowTubeMaterial(0xffe24a, 0.98, false);
    const helixHaloMat=makeFlowTubeMaterial(0xffe67a, 0.26, true);
    const helixHalo=new THREE.Mesh(helixGeom.geoHalo, helixHaloMat);
    const helixCore=new THREE.Mesh(helixGeom.geoCore, helixCoreMat);
    helixGroup.add(helixHalo); helixGroup.add(helixCore);
    const helixScatter={pos:randInSphere(3.6).add(new THREE.Vector3(0,2.2,0)), rot:new THREE.Euler(Math.random()*0.6, Math.random()*Math.PI*2, Math.random()*0.6)};

    function updateHelix(mix,t,dt){
      helixCoreMat.uniforms.uTime.value=t;
      helixHaloMat.uniforms.uTime.value=t;
      helixCoreMat.uniforms.uMix.value=mix;
      helixHaloMat.uniforms.uMix.value=mix;

      const p=new THREE.Vector3(
        lerp(0, helixScatter.pos.x, mix),
        lerp(0, helixScatter.pos.y, mix),
        lerp(0, helixScatter.pos.z, mix),
      );
      p.x += Math.sin(t*0.55)*0.12*mix;
      p.y += Math.sin(t*0.40)*0.08*mix;
      p.z += Math.cos(t*0.55)*0.12*mix;

      helixGroup.position.lerp(p, 1 - Math.exp(-10*dt));
      helixGroup.rotation.y=lerp(helixGroup.rotation.y, lerp(0,helixScatter.rot.y,mix), 1 - Math.exp(-10*dt));
      helixGroup.rotation.x=lerp(helixGroup.rotation.x, lerp(0,helixScatter.rot.x,mix), 1 - Math.exp(-10*dt));
      helixGroup.rotation.z=lerp(helixGroup.rotation.z, lerp(0,helixScatter.rot.z,mix), 1 - Math.exp(-10*dt));
    }

    /********************
     * Photos (7)
     ********************/
    const photoMax=7;
    const photoMeshes=[], photoUrls=[];
    const photoCountEl=$("photoCount");
    const photoInput=$("photoInput");
    const resetPhotosBtn=$("resetPhotosBtn");
    const textureLoader=new THREE.TextureLoader();

    function makePlaceholderTexture(text){
      const c=document.createElement("canvas"); c.width=512; c.height=512;
      const ctx=c.getContext("2d");
      ctx.fillStyle="#140c16"; ctx.fillRect(0,0,512,512);
      ctx.fillStyle="rgba(255,255,255,0.03)";
      for(let i=0;i<80;i++) ctx.fillRect(Math.random()*512,Math.random()*512,Math.random()*60,2);
      ctx.fillStyle="rgba(255,215,166,0.92)";
      ctx.font="bold 42px system-ui"; ctx.textAlign="center";
      ctx.fillText("ä¸Šä¼ ç…§ç‰‡",256,240);
      ctx.fillStyle="rgba(255,255,255,0.75)";
      ctx.font="26px system-ui";
      ctx.fillText(text,256,290);
      const tex=new THREE.CanvasTexture(c); tex.colorSpace=THREE.SRGBColorSpace;
      return tex;
    }

    function buildPhotoSlots(){
      const folded=[], scatter=[];
      const bands=[0.18,0.32,0.46,0.60,0.72,0.84,0.92];
      const angles=[0.2,1.1,2.2,3.1,4.2,5.1,5.9];
      for(let i=0;i<photoMax;i++){
        const t=clamp(bands[i]+(Math.random()-0.5)*0.02,0.10,0.96);
        const ang=angles[i]+(Math.random()-0.5)*0.10;
        folded.push(coneSurfacePos(t,ang,2.18,4.60).multiplyScalar(1.06));
        scatter.push(randInSphere(3.9).add(new THREE.Vector3(0,2.2,0)));
      }
      return {folded,scatter};
    }
    const photoTargets=buildPhotoSlots();
    const interactiveMeshes=[];
    function buildPhotoMeshes(){
      const geo=new THREE.PlaneGeometry(1,1);
      for(let i=0;i<photoMax;i++){
        const tex=makePlaceholderTexture(`${i+1}/7`);
        const imgMat=new THREE.MeshBasicMaterial({map:tex,transparent:true,opacity:0.98});
        const img=new THREE.Mesh(geo,imgMat); img.userData.pickParentIndex=i;

        const frameMat=new THREE.MeshStandardMaterial({
          color:COLORS.goldBright, metalness:1.0, roughness:0.14,
          emissive:new THREE.Color(0x3a1a00), emissiveIntensity:0.20
        });
        const frame=new THREE.Mesh(geo,frameMat);
        frame.scale.set(1.10,1.10,1);
        frame.position.z=-0.001;
        frame.userData.pickParentIndex=i;

        const group=new THREE.Group();
        group.add(frame); group.add(img);
        const s=0.62; group.scale.set(s,s,s);
        group.position.copy(photoTargets.folded[i]);
        group.lookAt(camera.position);
        group.userData={index:i, folded:photoTargets.folded[i].clone(), scatter:photoTargets.scatter[i].clone(), baseScale:s, driftSeed:Math.random()*Math.PI*2, aspect:1.0};
        treeGroup.add(group);
        photoMeshes.push(group);
        interactiveMeshes.push(frame,img);
      }
    }
    buildPhotoMeshes();

    function updatePhotoCount(){ photoCountEl.textContent=`${photoUrls.length}/${photoMax}`; }
    updatePhotoCount();

    function setPhotoTexture(i,url){
      textureLoader.load(url,(tex)=>{
        tex.colorSpace=THREE.SRGBColorSpace;
        tex.minFilter=THREE.LinearMipmapLinearFilter;
        tex.magFilter=THREE.LinearFilter;
        tex.generateMipmaps=true;
        tex.anisotropy=Math.min(12, renderer.capabilities.getMaxAnisotropy?.() || 1);

        const group=photoMeshes[i];
        const imgMesh=group.children[1];
        const old=imgMesh.material.map; if(old) old.dispose();
        imgMesh.material.map=tex; imgMesh.material.needsUpdate=true;

        const w=tex.image?.width||1, h=tex.image?.height||1;
        const aspect=w/h;
        group.userData.aspect=aspect;

        const sx=aspect>=1?1.0:aspect;
        const sy=aspect>=1?1.0/aspect:1.0;
        imgMesh.scale.set(sx,sy,1);
        group.children[0].scale.set(sx*1.10,sy*1.10,1);
      });
    }

    photoInput.addEventListener("change",(e)=>{
      const files=Array.from(e.target.files||[]);
      if(!files.length) return;
      const chosen=files.slice(0,photoMax);
      photoUrls.length=0;
      for(let i=0;i<chosen.length;i++){
        const url=URL.createObjectURL(chosen[i]);
        photoUrls.push(url);
        setPhotoTexture(i,url);
      }
      for(let i=chosen.length;i<photoMax;i++){
        const g=photoMeshes[i], img=g.children[1];
        const old=img.material.map; if(old) old.dispose();
        img.material.map=makePlaceholderTexture(`${i+1}/7`);
        img.material.needsUpdate=true;
        g.userData.aspect=1.0;
        img.scale.set(1,1,1);
        g.children[0].scale.set(1.10,1.10,1);
      }
      updatePhotoCount();
      photoInput.value="";
    });

    resetPhotosBtn.addEventListener("click",()=>{
      photoUrls.length=0;
      for(let i=0;i<photoMax;i++){
        const g=photoMeshes[i], img=g.children[1];
        const old=img.material.map; if(old) old.dispose();
        img.material.map=makePlaceholderTexture(`${i+1}/7`);
        img.material.needsUpdate=true;
        g.userData.aspect=1.0;
        img.scale.set(1,1,1);
        g.children[0].scale.set(1.10,1.10,1);
      }
      updatePhotoCount();
    });

    /********************
     * Mode + camera rotate
     ********************/
    const MODE={FOLD:"FOLD", SCATTER:"SCATTER", PHOTO:"PHOTO"};
    let targetMode=MODE.FOLD;
    const modePill=$("modePill");

    let foldMix=0, foldVel=0;
    let focusedPhoto=null;
    let photoZoom=0, photoZoomVel=0;

    let rotY=0, rotX=0, rotZ=0;
    let targetRotY=0, targetRotX=0, targetRotZ=0;
    let orbitYaw=0, orbitPitch=0;

    function setMode(m){
      if(targetMode===MODE.PHOTO && m!==MODE.PHOTO && focusedPhoto){
        treeGroup.attach(focusedPhoto);
      }
      targetMode=m;
      modePill.textContent = (m===MODE.FOLD)?"çŠ¶æ€ï¼šåˆæ‹¢æ€":(m===MODE.SCATTER)?"çŠ¶æ€ï¼šæ•£å¼€æ€":"çŠ¶æ€ï¼šç…§ç‰‡æ”¾å¤§æ€";
      if(m===MODE.PHOTO && focusedPhoto) overlayGroup.attach(focusedPhoto);
    }

    function springTo(x,v,target,dt,k=22,d=8){
      const a=(target-x)*k - v*d;
      v+=a*dt; x+=v*dt;
      return [x,v];
    }

    function updatePhotos(mix,t,dt){
      for(const g of photoMeshes){
        const f=g.userData.folded, s=g.userData.scatter, seed=g.userData.driftSeed;

        if(targetMode===MODE.PHOTO && focusedPhoto===g){
          const depth=2.75;
          const forward=camera.getWorldDirection(new THREE.Vector3());
          const targetPos=camera.position.clone().add(forward.multiplyScalar(depth));
          g.position.lerp(targetPos, 1 - Math.exp(-16*dt));
          g.quaternion.copy(camera.quaternion);

          const vFov=THREE.MathUtils.degToRad(camera.fov);
          const visibleH=2*Math.tan(vFov/2)*depth;
          const visibleW=visibleH*camera.aspect;

          const frame=g.children[0];
          const frameW=frame.scale.x, frameH=frame.scale.y;

          const safeW=visibleW*0.78, safeH=visibleH*0.72;
          const fitScale=Math.min(safeW/frameW, safeH/frameH);
          const base=g.userData.baseScale;
          const targetScale=lerp(base, fitScale, photoZoom);

          g.scale.lerp(new THREE.Vector3(targetScale,targetScale,targetScale), 1 - Math.exp(-14*dt));
          continue;
        }

        let p=new THREE.Vector3(lerp(f.x,s.x,mix), lerp(f.y,s.y,mix), lerp(f.z,s.z,mix));
        p.x += Math.sin(t*0.8+seed)*0.12*mix;
        p.y += Math.sin(t*0.65+seed*1.3)*0.08*mix;
        p.z += Math.cos(t*0.75+seed*0.9)*0.12*mix;

        g.position.copy(p);
        g.lookAt(camera.position);

        const baseS=g.userData.baseScale;
        g.scale.lerp(new THREE.Vector3(baseS,baseS,baseS), 1 - Math.exp(-12*dt));
      }
    }

    /********************
     * Raycast pick by pinch screen pos
     ********************/
    const raycaster=new THREE.Raycaster();
    const ndc=new THREE.Vector2();
    function pickPhotoByScreen01(x01,y01){
      ndc.set(x01*2-1, -(y01*2-1));
      raycaster.setFromCamera(ndc,camera);
      const hits=raycaster.intersectObjects(interactiveMeshes,false);
      if(!hits.length) return null;
      const idx=hits[0].object?.userData?.pickParentIndex;
      return (typeof idx==="number") ? (photoMeshes[idx]||null) : null;
    }

    /********************
     * Touch drag fallback rotate
     ********************/
    let dragging=false,lastX=0,lastY=0;
    canvas.addEventListener("pointerdown",(e)=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; canvas.setPointerCapture(e.pointerId); });
    canvas.addEventListener("pointerup",()=>dragging=false);
    canvas.addEventListener("pointercancel",()=>dragging=false);
    canvas.addEventListener("pointermove",(e)=>{
      if(!dragging) return;
      const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
      orbitYaw += dx*0.006;
      orbitPitch += dy*0.004;
      orbitPitch=clamp(orbitPitch,-0.55,0.75);
      targetRotY=orbitYaw; targetRotX=orbitPitch;
      targetRotZ=lerp(targetRotZ, -dx*0.0008, 0.25);
    });

    /********************
     * Gesture: MediaPipe Hands (NO concurrency)
     ********************/
    const camBtn=$("camBtn");
    const camSelect=$("camSelect");
    const camGate=$("camGate");
    const camGateBtn=$("camGateBtn");
    const camGateClose=$("camGateClose");
    const camPill=$("camPill");
    const gesturePill=$("gesturePill");
    const gestureDbg=$("gestureDbg");
    const video=$("video");

    let hands=null;
    let camOn=false;
    let stream=null;
    let busy=false;      // <<< å…³é”®ï¼šé˜²å¹¶å‘
    let rafId=0;

    // gesture state
    let pinchActive=false;
    let pinchHold=0, pinchRelease=0;
    let openHold=0, fistHold=0;
    let lastWrist=null, lastAngle=null;
    let rollTarget=0;

    function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
    function unwrapDeltaAngle(a,b){
      let d=b-a; while(d>Math.PI) d-=Math.PI*2; while(d<-Math.PI) d+=Math.PI*2; return d;
    }
    function landmark01(lm,i){ return { x:1-lm[i].x, y:lm[i].y }; }

    function classifyGesture(lm){
      const wrist=landmark01(lm,0);
      const indexMCP=landmark01(lm,5);
      const middleMCP=landmark01(lm,9);
      const thumbTip=landmark01(lm,4);
      const indexTip=landmark01(lm,8);
      const middleTip=landmark01(lm,12);
      const ringTip=landmark01(lm,16);
      const pinkyTip=landmark01(lm,20);

      const indexPIP=landmark01(lm,6);
      const middlePIP=landmark01(lm,10);
      const ringPIP=landmark01(lm,14);
      const pinkyPIP=landmark01(lm,18);

      const palmSize=Math.max(0.06, dist2(wrist,middleMCP));
      const extThresh=0.28*palmSize;

      const idxExt=(indexPIP.y-indexTip.y) > extThresh;
      const midExt=(middlePIP.y-middleTip.y) > extThresh;
      const rngExt=(ringPIP.y-ringTip.y) > extThresh;
      const pkyExt=(pinkyPIP.y-pinkyTip.y) > extThresh;

      const thumbSpread=Math.abs(thumbTip.x-indexMCP.x);
      const thbExt=thumbSpread > 0.35*palmSize;

      const extCount=(idxExt?1:0)+(midExt?1:0)+(rngExt?1:0)+(pkyExt?1:0);
      const spread=dist2(indexTip,pinkyTip);
      const isOpenPalm=(extCount>=4) && (thbExt || spread>0.95*palmSize);

      const tipAvgToWrist=(dist2(indexTip,wrist)+dist2(middleTip,wrist)+dist2(ringTip,wrist)+dist2(pinkyTip,wrist))/4;
      const isFist=(extCount<=1) && (tipAvgToWrist < 0.85*palmSize);

      const pinchDist=dist2(thumbTip,indexTip);
      const pinchOn = pinchDist < 0.33*palmSize;
      const pinchOff= pinchDist > 0.44*palmSize;

      const palmDir=Math.atan2(middleMCP.y-wrist.y, middleMCP.x-wrist.x);

      return {
        wrist,palmSize,isOpenPalm,isFist,pinchOn,pinchOff,
        pinchPos:{x:(thumbTip.x+indexTip.x)/2, y:(thumbTip.y+indexTip.y)/2},
        palmDir, pinchNorm:clamp(pinchDist/palmSize,0,2)
      };
    }

    async function initHands(){
      if(hands) return;
      if(typeof Hands==="undefined") throw new Error("MediaPipe Hands æœªåŠ è½½ï¼ˆHands is undefinedï¼‰");
      hands=new Hands({ locateFile:(file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}` });
      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: isMobileLike ? 0 : 1,
        minDetectionConfidence: 0.62,
        minTrackingConfidence: 0.58
      });
      hands.onResults(onHandsResults);
    }

    async function refreshCameraList(){
      if(!navigator.mediaDevices?.enumerateDevices) return;
      try{
        const devices=await navigator.mediaDevices.enumerateDevices();
        const cams=devices.filter(d=>d.kind==="videoinput");
        camSelect.innerHTML = `<option value="">é»˜è®¤æ‘„åƒå¤´</option>`;
        cams.forEach((d,i)=>{
          const opt=document.createElement("option");
          opt.value=d.deviceId;
          opt.textContent=d.label || `Camera ${i+1}`;
          camSelect.appendChild(opt);
        });
      }catch{}
    }

    async function startCamera(deviceId=""){
      await initHands();

      if(!navigator.mediaDevices?.getUserMedia){
        showError("æ­¤æµè§ˆå™¨ä¸æ”¯æŒ getUserMediaï¼Œæ— æ³•å¯ç”¨æ‘„åƒå¤´æ‰‹åŠ¿ã€‚"); return;
      }
      if(location.protocol!=="https:" && location.hostname!=="localhost"){
        showError("æ‘„åƒå¤´åªèƒ½åœ¨ HTTPS æˆ– localhost ä¸‹ä½¿ç”¨ã€‚è¯·ç”¨ GitHub Pages çš„ https é“¾æ¥æ‰“å¼€ã€‚"); return;
      }

      stopCamera(); // clear

      const constraints={
        audio:false,
        video:{
          facingMode:"user",
          width:{ideal:isMobileLike?640:960},
          height:{ideal:isMobileLike?480:720},
          ...(deviceId?{deviceId:{exact:deviceId}}:{})
        }
      };

      try{
        stream=await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject=stream;
        await video.play();

        // reset gesture states
        busy=false; pinchActive=false; pinchHold=0; pinchRelease=0;
        openHold=0; fistHold=0; lastWrist=null; lastAngle=null;

        camOn=true;
        camBtn.textContent="æ‘„åƒå¤´ï¼šå¼€å¯";
        camPill.textContent="Gesture: on";
        gesturePill.textContent="è¯†åˆ«ï¼šè¿è¡Œä¸­â€¦";

        // IMPORTANT: processing loop with busy lock (NO concurrency)
        const loop = async ()=>{
          if(!camOn) return;
          rafId=requestAnimationFrame(loop);

          // video not ready => skip
          if(video.readyState < 2 || video.videoWidth===0 || video.videoHeight===0) return;
          if(busy) return;

          busy=true;
          try{
            await hands.send({image: video});
          }catch(err){
            // å¦‚æœ still abortï¼šç»™å‡ºæ›´å¯è¯»çš„æç¤º
            showError(
              "æ‰‹åŠ¿è¯†åˆ«å¼•æ“å´©æºƒï¼ˆå¸¸è§åŸå› ï¼šå¹¶å‘å–‚å¸§/æµè§ˆå™¨ WebAssembly é—®é¢˜ï¼‰ã€‚\n\n" +
              "å½“å‰å·²ä½¿ç”¨â€œbusy é”â€é¿å…å¹¶å‘ã€‚\n" +
              "è‹¥ä»å‡ºç°ï¼Œè¯·å°è¯•ï¼š\n" +
              "1) æ¢ Chrome/Edge æ‰“å¼€\n" +
              "2) å…³é—­ä½ç”µé‡æ¨¡å¼/çœç”µæ¨¡å¼\n" +
              "3) åœ¨é“¾æ¥ååŠ  ?v=3 å¼ºåˆ¶åˆ·æ–°ç¼“å­˜\n\n" +
              "åŸå§‹é”™è¯¯ï¼š\n" + (err?.message||err)
            );
            stopCamera();
          }finally{
            busy=false;
          }
        };
        loop();

        await refreshCameraList();
      }catch(err){
        stopCamera();
        showError("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼š\n" + (err?.message||err));
      }
    }

    function stopCamera(){
      camOn=false;
      camBtn.textContent="æ‘„åƒå¤´ï¼šå…³é—­";
      camPill.textContent="Gesture: off";
      gesturePill.textContent="è¯†åˆ«ï¼š-";
      gestureDbg.textContent="dbg:-";
      lastWrist=null; lastAngle=null;
      if(rafId) cancelAnimationFrame(rafId);
      rafId=0;

      try{
        if(stream){
          stream.getTracks().forEach(t=>t.stop());
        }
      }catch{}
      stream=null;
      video.srcObject=null;
    }

    function onHandsResults(results){
      if(!results?.multiHandLandmarks?.length){
        gesturePill.textContent = camOn ? "è¯†åˆ«ï¼šæœªæ£€æµ‹åˆ°æ‰‹" : "è¯†åˆ«ï¼š-";
        gestureDbg.textContent = "dbg:nohand";
        // ä¸¢æ‰‹ï¼šå¦‚æœåœ¨ pinch ä¸­ï¼ŒæŒ‰æ¾å¼€å¤„ç†
        if(pinchActive){
          pinchRelease++;
          if(pinchRelease>=2){
            pinchActive=false; pinchRelease=0;
            focusedPhoto=null;
            setMode(MODE.SCATTER);
          }
        }
        lastWrist=null; lastAngle=null;
        return;
      }

      const lm=results.multiHandLandmarks[0];
      const g=classifyGesture(lm);
      gestureDbg.textContent = `dbg: pinch=${g.pinchNorm.toFixed(2)} palm=${g.palmSize.toFixed(3)}`;

      let label="-";

      // Priority: pinch > fist > open
      if(!pinchActive){
        if(g.pinchOn){
          pinchHold++;
          if(pinchHold>=2){
            pinchActive=true;
            pinchHold=0;
            pinchRelease=0;
            label="Pinch æŠ“å–";

            const picked=pickPhotoByScreen01(g.pinchPos.x, g.pinchPos.y);
            focusedPhoto = picked || photoMeshes[0] || null;
            if(focusedPhoto) setMode(MODE.PHOTO); else setMode(MODE.SCATTER);
          }
        }else pinchHold=0;
      }else{
        label="Pinch æŠ“å–ä¸­";
        if(g.pinchOff){
          pinchRelease++;
          if(pinchRelease>=2){
            pinchActive=false;
            pinchRelease=0;
            focusedPhoto=null;
            setMode(MODE.SCATTER);
          }
        }else pinchRelease=0;
      }

      if(!pinchActive){
        if(g.isFist){
          fistHold++; openHold=0;
          label="æ¡æ‹³";
          if(fistHold>=2){
            fistHold=2;
            setMode(MODE.FOLD);
          }
        }else fistHold=0;

        if(g.isOpenPalm){
          openHold++;
          label = (targetMode===MODE.SCATTER) ? "äº”æŒ‡å¼ å¼€ï¼ˆæ—‹è½¬ï¼‰" : "äº”æŒ‡å¼ å¼€";
          if(openHold>=2){
            openHold=2;
            setMode(MODE.SCATTER);
          }
        }else{
          openHold=Math.max(0, openHold-1);
        }

        // rotate only in scatter + openPalm
        if(targetMode===MODE.SCATTER && g.isOpenPalm){
          const wrist=g.wrist;
          const dir=g.palmDir;

          if(lastWrist){
            const dx=(wrist.x-lastWrist.x);
            const dy=(wrist.y-lastWrist.y);

            // æ›´â€œè·Ÿæ‰‹â€ï¼šdx çš„ yaw + æ‰‹è…•æ–¹å‘å˜åŒ–çš„ yawï¼ˆè½¬ä¸€åœˆè·Ÿä¸€åœˆï¼‰
            const moveYaw   = dx * (isMobileLike ? 10.5 : 9.6);
            const movePitch = dy * (isMobileLike ? 8.0 : 7.2);

            orbitYaw   += moveYaw;
            orbitPitch += movePitch;
            orbitPitch = clamp(orbitPitch, -0.55, 0.75);

            if(lastAngle!==null){
              const dAng=unwrapDeltaAngle(lastAngle, dir);
              orbitYaw += dAng * 1.05;      // æ‰‹è…•è½¬ä¸€åœˆâ‰ˆåœºæ™¯è½¬ä¸€åœˆ
              rollTarget = clamp(dAng, -0.35, 0.35) * 0.35 + dx * 0.18;
            }
          }

          lastWrist=wrist;
          lastAngle=dir;
          targetRotY=orbitYaw;
          targetRotX=orbitPitch;
          targetRotZ=lerp(targetRotZ, rollTarget, 0.35);
        }else{
          lastWrist=null; lastAngle=null;
          targetRotZ=lerp(targetRotZ, 0, 0.10);
        }
      }

      gesturePill.textContent="è¯†åˆ«ï¼š"+label;
    }

    // UI actions
    camBtn.addEventListener("click", ()=>{
      if(!camOn) $("camGate").style.display="flex";
      else stopCamera();
    });
    camGateBtn.addEventListener("click", async ()=>{
      camGate.style.display="none";
      await startCamera(camSelect.value || "");
    });
    camGateClose.addEventListener("click", ()=>camGate.style.display="none");
    camSelect.addEventListener("change", async ()=>{ if(camOn) await startCamera(camSelect.value||""); });
    refreshCameraList();

    /********************
     * Main loop
     ********************/
    let tPrev=now();
    let firstFrame=true;

    function animate(){
      requestAnimationFrame(animate);
      const t=now();
      const dt=clamp(t-tPrev,0.001,0.033);
      tPrev=t;

      // fold mix spring
      const foldTarget = (targetMode===MODE.FOLD) ? 0 : 1;
      [foldMix, foldVel] = springTo(foldMix, foldVel, foldTarget, dt, 18, 8);

      // photo zoom spring
      const zoomTarget = (targetMode===MODE.PHOTO && focusedPhoto) ? 1 : 0;
      [photoZoom, photoZoomVel] = springTo(photoZoom, photoZoomVel, zoomTarget, dt, 26, 12);
      photoZoom=clamp(photoZoom,0,1);

      // rotation smoothing
      rotY = lerp(rotY, targetRotY, 1 - Math.exp(-26*dt));
      rotX = lerp(rotX, targetRotX, 1 - Math.exp(-26*dt));
      rotZ = lerp(rotZ, targetRotZ, 1 - Math.exp(-20*dt));
      treeGroup.rotation.set(rotX, rotY, rotZ);

      // update scene
      updateInstanced(ballsGold, foldMix, t);
      updateInstanced(ballsRed,  foldMix, t);
      updateHelix(foldMix, t, dt);

      // needles shimmer
      if(needlePoints){
        const shimmer=0.9+0.1*Math.sin(t*1.4);
        needlePoints.material.size=0.042+0.012*shimmer;
        needlePoints.material.opacity=0.92+0.08*Math.sin(t*0.80);
      }

      // star glow
      star.rotation.y=t*0.55; star.rotation.x=t*0.30;
      starGlow.material.opacity=0.38+0.12*Math.sin(t*2.0);
      starGlow.scale.set(2.9+0.22*Math.sin(t*1.6), 2.9+0.22*Math.sin(t*1.6), 1);

      // photos
      for(const g of photoMeshes){
        const f=g.userData.folded, s=g.userData.scatter, seed=g.userData.driftSeed;

        if(targetMode===MODE.PHOTO && focusedPhoto===g){
          const depth=2.75;
          const forward=camera.getWorldDirection(new THREE.Vector3());
          const targetPos=camera.position.clone().add(forward.multiplyScalar(depth));
          g.position.lerp(targetPos, 1 - Math.exp(-16*dt));
          g.quaternion.copy(camera.quaternion);

          const vFov=THREE.MathUtils.degToRad(camera.fov);
          const visibleH=2*Math.tan(vFov/2)*depth;
          const visibleW=visibleH*camera.aspect;

          const frame=g.children[0];
          const frameW=frame.scale.x, frameH=frame.scale.y;
          const safeW=visibleW*0.78, safeH=visibleH*0.72;
          const fitScale=Math.min(safeW/frameW, safeH/frameH);

          const base=g.userData.baseScale;
          const targetScale=lerp(base, fitScale, photoZoom);
          g.scale.lerp(new THREE.Vector3(targetScale,targetScale,targetScale), 1 - Math.exp(-14*dt));

          // DOF stronger in photo mode
          if(bokehPass){
            const dist=camera.position.distanceTo(g.getWorldPosition(new THREE.Vector3()));
            bokehPass.materialBokeh.uniforms.focus.value=dist;
            bokehPass.materialBokeh.uniforms.maxblur.value=lerp(isMobileLike?0.015:0.020, isMobileLike?0.022:0.030, photoZoom);
          }
          continue;
        }

        // not focused
        let p=new THREE.Vector3(lerp(f.x,s.x,foldMix), lerp(f.y,s.y,foldMix), lerp(f.z,s.z,foldMix));
        p.x += Math.sin(t*0.8+seed)*0.12*foldMix;
        p.y += Math.sin(t*0.65+seed*1.3)*0.08*foldMix;
        p.z += Math.cos(t*0.75+seed*0.9)*0.12*foldMix;

        g.position.copy(p);
        g.lookAt(camera.position);
        const baseS=g.userData.baseScale;
        g.scale.lerp(new THREE.Vector3(baseS,baseS,baseS), 1 - Math.exp(-12*dt));
      }
      if(bokehPass && !(targetMode===MODE.PHOTO && focusedPhoto)){
        bokehPass.materialBokeh.uniforms.focus.value=6.8;
        bokehPass.materialBokeh.uniforms.maxblur.value=isMobileLike?0.012:0.014;
      }

      // render
      if(composer) composer.render(); else renderer.render(scene,camera);

      if(firstFrame){ firstFrame=false; loading.style.display="none"; }
    }
    animate();

    function handleResize(){
      renderer.setSize(innerWidth,innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, isMobileLike?1.6:2));
      applyLayoutByAspect();
      if(composer) composer.setSize(innerWidth,innerHeight);
      if(bloomPass) bloomPass.setSize(innerWidth,innerHeight);
    }
    addEventListener("resize", handleResize);
    addEventListener("orientationchange", handleResize);

    // init mode
    setMode(MODE.FOLD);
  </script>
</body>
</html>
